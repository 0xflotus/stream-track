This directory contains tools finding upstream commits that fixes or mentions
specific downstream commits and checking whether the followup changes in the
upstream are already in your downstream tree.

Suppose that you are developing your custom linux kernel on a branch based on a
v5.4 stable release.  You periodically rebase your work on latest 5.4 stable
release to ensure your kernel is safe.  But, you also back-ported some commits
from v5.5.  Now the periodic rebasing cannot ensure you have all necessary
fixes in your kernel, as the fixes for the back-ported commits will not land on
5.4 stable releases.  This problem case is not only linux kernel project
specific but general for many open source projects.  The tools can help finding
such commits.

Getting Started
===============

Let's suppose your kernel repo is at '$HOME/linux' and tracking the mainline
tree with a remote name 'mainline'.  Your working branch is named 'hack' and
based on v5.4.42.  Set PATH to point this directory, move to your kernel source
tree and run below command:

    $ ./chk-followups.py --repo $HOME/linux \
            --downstream v5.4.42..hack --upstream v5.5..mainline/master

Above command will do the check for all commits in 'v5.4.42..hack' against all
commits in 'v5.5..mainline/master'.

Output Format
-------------

The output of 'chk-followups.py' will classify each of the downstream commits
with a combination of below tags:

 - downstream_only: The commit is in the downstream only.  Maybe you made this
   change on your own.
 - no_followup: The upstream has no commits for the commit.
 - fixed: There are upstream commits fixing the commit.  This is classified by
   checking the 'Fixes' tag.
 - mentioned: There are upstream commits mentioning the commit.  This could be
   non-fixes (e.g., merge), but would be worth to check.
 - unmerged: The followup commit is not merged in the downstream.  You should
   carefully check how things are going on.

In case of fixed or mentioned, the followup commits will also be listed.  For
example:

    x86/unwind/orc: Prevent unwinding before ORC initialization # fixed
      fixes merged
        71c95825289f ("x86/unwind/orc: Fix error handling in __unwind_start()")
    bnxt_en: Improve AER slot reset. # fixed,unmerged
      fixes unmerged
        6e2f83884c09 ("bnxt_en: Fix AER reset logic on 57500 chips.")
    KEYS: Don't write out to userspace while holding key semaphore # mentioned,unmerged
      mentions unmerged
        4c205c84e249 ("Merge tag 'keys-fixes-20200329' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs")

Speed Optimization
==================

Because 'chk-followups.py' should read each commits in the downstream revision
range and the upstream revision range, the runtime can be so long in many
cases.  For example, tracking for 4.9 stable releases (v4.9..stable/linux-4.9.y
as downstream and v4.10..linux/master as upstream) takes more than 10 hours on
some computers.  We provide some optimization tricks for the runtime reduction.

Dedicated Downstream Only Commit Prefix
---------------------------------------

For each of the downstream commits, the tool first checks whether the commit is
backported from the upstream or not.  If not, it couldn't have followup and
therefore the check is finished.  If the number of downstream only commit is
high in your case, most of the tracking time will be used for this check.

Some people use a dedicated prefix in the commit title to easily distinguish
the downstream only commits from backported commits.  If you are also using
this strategy, you could let the tool know this by using '--downstream_prefix'
option of 'chk-followups.py'.  If it is given, the tool will be able to know
the commit is downstream only by simply reading the title.

Using Previous Results as a Cache
---------------------------------

The tracking will be periodically repeated, as the upstream will keep changing.
In that case, as the ranges of the downstream and the downstream will only
subtly changed, the tracking could be finished shortly if we can use the
previous tracking results.  You can let the tool to know the previous tracking
results using '--prev_results' option of 'chk-followups.py'.

Summarizing Repeated Tracking Results
=====================================

Users would repeatedly do the tracking, as long as the upstream is live and
keep changing.  Because the purpose of the repeated tracking is only finding
new followups, the 'chk-followups.py' outputs of each repeated runs would be
too verbose.  You can get a summary of the outputs by storing the outputs in
files and giving the list of the files to 'summary_outputs.py'.  The summary
will be something like below:

    # cmmt: The downstream commits
    # port: The downstream commits back-ported from the upstream
    # fixs: The upstream commits fixing the 'port'
    # ufix: 'fixs' that unapplied in the downstream
    # mntn: The upstream commits mentioning the 'port'
    # umnt: 'mntn' that unapplied in the downstream
    #
                 file       cmmt    port    fixs    ufix    mntn    umnt
    2020-07-16/5.4-stable   6633    4229    131     18      62      15      # up: 2020-01-26..2020-07-15 dn: 2019-11-24..2020-07-16
    2020-07-17/5.4-stable   6633    4229    132     19      62      15      # up: 2020-01-26..2020-07-17 dn: 2019-11-24..2020-07-16
    2020-07-19/5.4-stable   6633    4229    132     19      62      15      # up: 2020-01-26..2020-07-19 dn: 2019-11-24..2020-07-16
    2020-07-21/5.4-stable   6633    4229    133     20      62      15      # up: 2020-01-26..2020-07-20 dn: 2019-11-24..2020-07-16
    2020-07-23/5.4-stable   6848    4434    139     10      65      16      # up: 2020-01-26..2020-07-23 dn: 2019-11-24..2020-07-22
    2020-07-25/5.4-stable   6848    4434    145     16      66      17      # up: 2020-01-26..2020-07-25 dn: 2019-11-24..2020-07-22
    2020-07-27/5.4-stable   6848    4434    147     18      70      21      # up: 2020-01-26..2020-07-26 dn: 2019-11-24..2020-07-22
